



# 代码说明



​												图1.1





代码一共分为四大部分(参见图1.1，图1.2)，详细说明见下，相关图片可以在image文件夹里查阅大图。

1. 数据读取

   - 六大类因子读取  <def read_factor_data(factors_name_list, trade_date_20d_series)>
   - 十个风险因子读取  <def risk_factor(alpha_factor_series)>

2. 空值填充  <def nonefill(data,date_list)>

3. 概率预测 

   -  <def reg_factor_concat(fill_alpha_factor_series,model,loop,date_list)>

   - <class AveragingModels(BaseEstimator, RegressorMixin, TransformerMixin)>

   - <class StackingAveragedModels(BaseEstimator, RegressorMixin, TransformerMixin)>

4. 因子分析

   - 因子T检验<def factor_test_T(factor_list,factor_name)>
   - 因子检测1  <def factor_analyse(name,factor)>
   - 因子检测2  <def factor_stock_choose(factor,num)>





​											图1.2



## 详细说明

*1.数据读取

将特征值组合成一个DataFrame，形成输入数据。

每个特征值都按照Pandas的pickle形式存储在相应文件夹（数据通过SVN进行本地更新），一共分为六大类（factor_name_list = ['emotion', 'pricevol', 'mom', 'finance', 'valuation', 'alpha191']）

使用<def read_factor_data(factors_name_list, trade_date_20d_series)>读入每一类的所有特征值数据，合计116个。

每个特征数据都是Pandas DataFrame格式，index为股票代码，columns为日期，数据代表当期值，如下所示：

![1544153318810](C:\Users\yuanruyi\Desktop\Miya—Git\Quantitative-Trading\notebook\1544153318810.png)

使用<data_input(data,date_list,x)>将116个特征值组合成一个Pandas DataFrame格式，index为3619只股票代码，每一列代表一个特征所对应的数据，即columns为对应的116个特征，最后一列为日期date，倒数第二列为标签值rise_fall，倒数第三列trade_status为股票状态列（只选择为0的正常股票，其余非零状态股票为非正常股票，可能停牌，应该删除），最终 DataFrame构造如下：

![1544408952617](C:\Users\yuanruyi\Desktop\Miya—Git\Quantitative-Trading\notebook\1544408952617.png)



*2.数据处理

由于很多数据缺失，缺失值处理按照行业均值填充（建议是不处理，为了数据的真实性）



*3.划分测试集和训练集

按照滚动周期划分，循环预测得到每一期的数据值，输入的每期数据为numpy.arrary格式，需要将DataFrame进行划分。

月频数据：前12个月的值作为训练集，后一个月作为预测集。

周频数据：前48周的值作为训练集，后一个周作为预测集。



*4.进行预测

由于循环预测，每一期模型的最优参数都不一样，只能进行粗调，尽量保证每一次预测的精度都在50%以上。（为了避免过拟合，需要限制最大深度）



*5.因子数据合成

因子数据按照分类和回归分为两种。

分类：得到不同分类的两组概率值，选取分类为“1”（即上涨前T%类别）的概率值作为因子数据

回归：直接将回归预测得到的涨跌幅数值作为因子数据



*6.因子检验

因子检验分为三种

- 因子T检验
- 因子检测1
- 因子检测2：投资组合构建，直接将概率值排序前100只的股票选出，作为投资组合，分为两种方式：第一种直接等权构建， 即每只股票配置0.01的权重，第二种为按照基准行业权重进行配置





